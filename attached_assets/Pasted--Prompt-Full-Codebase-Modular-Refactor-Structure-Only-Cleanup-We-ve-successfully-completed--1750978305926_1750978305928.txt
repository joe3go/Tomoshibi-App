### âœ… Prompt: Full Codebase Modular Refactor (Structure-Only Cleanup)

Weâ€™ve successfully completed modular refactors in key areas (e.g., `Dashboard.tsx`) including:
- Extracting shared logic into reusable hooks
- Moving presentation into components
- Consolidating formatting and calculation utilities
- Centralizing all type/interface definitions

Now apply these same principles **across the entire codebase** to unify structure, reduce duplication, and increase maintainability â€” with zero change to functionality or UI.

---

ðŸ”’ **SAFETY REQUIREMENTS (DO NOT SKIP):**
- DO NOT change any application behavior, visual layout, or UX
- DO NOT introduce or remove functionality
- DO NOT make visual updates, logic changes, or styling edits
- This is a structure-only refactor â€” final output must be functionally and visually **identical**

---

### ðŸ§  OBJECTIVES:

#### 1. âœ… Modularize UI
- Extract meaningful UI blocks from large pages or views into reusable, named components
- Encapsulate fallback/loading/empty states inside each component
- Use props to cleanly separate data vs rendering logic

#### 2. âœ… Modularize Logic
- Move data fetching, mutation, state, and side-effect logic into custom React hooks
- Co-locate hook logic that shares state or context where helpful
- Use `useMemo`, `useCallback`, and derived state to reduce redundant computation

#### 3. âœ… Centralize Utility Functions
- Move repeated logic such as formatting, total calculations, ID checking, string cleaning, etc. into reusable utility or helper files
- Ensure no duplicate logic exists across components

#### 4. âœ… Reuse Extracted Logic & Components
- Where hooks or components already exist (e.g., profile, vocabulary stats, tutor cards), **reuse** instead of duplicating logic or markup
- Maintain a consistent approach for rendering layouts and data loading

#### 5. âœ… Clean Up Types
- Use shared interfaces or types where possible
- Remove any lingering inline types or duplicate interface definitions
- Ensure types are exported and reused cleanly across components/hooks

#### 6. âœ… Handle All Edge Cases Internally
- Each component/hook should gracefully handle:
  - Loading states
  - Null/empty data
  - Error or unexpected formats
- Avoid unsafe assumptions like `someArray.map(...)` without null checks

---

### âœ… COMPLETION CRITERIA

- [ ] No UI or logic lives in large page components unnecessarily
- [ ] All reusable logic is extracted into hooks or helpers
- [ ] All components are clean, prop-driven, and safely scoped
- [ ] Shared types/interfaces are centrally managed and reused
- [ ] All fallback/empty/loading states are encapsulated
- [ ] Final behavior and layout are visually and functionally unchanged
- [ ] `tsc --noEmit` passes with no type errors
- [ ] App loads, renders, and behaves 100% identically